---
title: "TSENAT: Tsallis Entropy Analysis Toolbox"
author: "Cristóbal Gallardo <gallardoalba@pm.me>"
date: "`r Sys.Date()`"
output:
    rmarkdown::html_document:
        toc: true
        fig_width: 10
        fig_height: 7
vignette: |
    %\VignetteIndexEntry{TSENAT}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r setup-global, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    fig.width = 10,
    fig.height = 6
)
```

## Overview

This vignette demonstrates how to compute and apply Tsallis entropy to
transcript-level expression data using `TSENAT`. It focuses on three
practical goals: (1) compute per-sample, per-gene diversity measures across a
range of sensitivity parameters `q`; (2) compare those measures between sample
groups; and (3) visualize and inspect transcript-level patterns that explain
differences.

### Motivation

Many genes express multiple isoforms whose relative abundances can be multimodal
or heavy-tailed. Standard mean-based comparisons may miss changes in isoform
dominance or heterogeneity. Tsallis entropy provides a tunable way to weight rare versus
dominant isoforms by varying `q`, producing a "q-curve" that reveals scale-dependent
diversity differences.

### High-level workflow

1. Preprocess counts and filter low-abundance transcripts.
2. Compute relative transcript proportions within each gene and evaluate
Tsallis entropy across one or more `q` values.
3. Summarize per-gene values across samples (mean/median) and test for
differences between groups (Wilcoxon or permutations).
4. Visualize q-curves and inspect transcript-level counts for top genes.


## What is Tsallis entropy?

Tsallis entropy is a one-parameter family of diversity measures that
generalizes Shannon entropy via a sensitivity parameter `q`. For a
discrete probability vector $p=(p_1,\dots,p_n)$ it is defined as

\[
S_q(p) = \frac{1-\sum_{i=1}^n p_i^q}{q-1}.
\]

Why use Tsallis entropy for gene-expression data?

Tsallis entropy provides a compact, flexible summary of
isoform-level heterogeneity that is particularly useful when biological
signals act at different abundance scales; combined with careful
preprocessing and resampling-based uncertainty quantification it is a
practical and interpretable tool for transcriptomics analyses. Key advantages:

- **Tunable sensitivity**: changing `q` shifts emphasis between rare and
dominant isoforms. Use small `q` (\(<1\)) to probe rare-isoform
heterogeneity and larger `q` (\(>1\)) to focus on dominant-isoform
behaviour; plotting `S_q` across a compact `q` grid (a "q-curve")
reveals scale-dependent differences between conditions.
- **Interpretability**: Tsallis maps to several familiar indices in limits
(Shannon at `q=1`, richness-like at `q=0`, Gini–Simpson at `q=2`), so
it unifies multiple perspectives on isoform diversity within one
framework.
- **Robust summary and diagnostics**: combined with Hill numbers and
q-curves, `S_q` supports concise reporting (effective isoform counts,
slope/AUC summaries) and targeted follow-up (transcript-level plots).

**Essential limiting cases**:

- Limit $q\to 1$: Shannon entropy, \(\lim_{q\to1} S_q(p) = -\sum_i p_i\log
p_i\).
- $q=0$: richness-like (number of expressed isoforms minus one).
- $q=2$: Gini–Simpson / collision index, \(S_2 = 1-\sum_i p_i^2\).
- Uniform maximum: for $m$ expressed isoforms,
\(S_{q,\max}(m)=\frac{1-m^{1-q}}{q-1}\) and normalized
\(\tilde S_q = S_q / S_{q,\max}(m)\).

**Use cases and interpretation**:

A gene with group separation only at low `q` suggests differences in
low-abundance (rare) isoforms; separation at high `q` indicates changes
in dominant isoforms. When both regimes differ, the q-curve will show
divergence across the entire `q` range.

Report `S_q` or Hill numbers `D_q` as appropriate for clarity: `D_q` converts 
entropies into an "effective number of isoforms" that is easy to interpret.

## Example dataset

An example dataset is included for demonstration. Load the package and data:

```{r setup}
# Load packages
suppressPackageStartupMessages({
    library(TSENAT)
    library(ggplot2)
    library(SummarizedExperiment)
    library(mgcv)
})
```

### Sample naming and pairing requirements

TSENAT requires a consistent, exact mapping between the assay column names
and the values in `coldata$Sample`. The following rules and recommendations
make mapping reliable and avoid surprises when running paired analyses.

- Naming convention: for paired comparisons use a shared base identifier and
    a role suffix, e.g. `SAMPLE_N` / `SAMPLE_T` or `SAMPLE_Normal` /
    `SAMPLE_Tumor`. The helper `infer_sample_group()` recognizes common
    underscore suffixes (like `_N` / `_T`) and common TCGA-style tokens.
- Validation and metadata: to perform paired analyses call
    `map_coldata_to_se(..., paired = TRUE)`. When `paired = TRUE` the
    function will reorder columns to follow `coldata`, add `sample_type`
    and `sample_base` to `colData(ts_se)`, and check that each `sample_base`
    has entries for all groups, returning an informative error if not.


The following example from `coldata_df` illustrates a correct format:

```text
Sample	Condition
TCGA-A7-A0CH_N	Normal
TCGA-A7-A0D9_N	Normal
TCGA-A7-A0CH_T	Tumor
TCGA-A7-A0D9_T	Tumor
```

### Load data and metadata

Now we load the example dataset and associated metadata:

```{r data}
# Load required files
coldata_tsv <- system.file("extdata", "coldata.tsv", package = "TSENAT")
tx2gene_tsv <- system.file("extdata", "tx2gene.tsv", package = "TSENAT")
data("tcga_brca_luma_dataset", package = "TSENAT", envir = globalenv())

# Extract gene names and read count data (do not reference ts_se yet)
genes <- tcga_brca_luma_dataset[, 1]
readcounts <- tcga_brca_luma_dataset[, -1]

# Assign transcript IDs as rownames of `readcounts`
# so downstream transcript-level plotting functions can use them.
txmap <- utils::read.delim(tx2gene_tsv, header = TRUE, stringsAsFactors = FALSE)
rownames(readcounts) <- as.character(txmap$Transcript)

# Read sample metadata
coldata_df <- read.table(coldata_tsv,
    header = TRUE,
    sep = "\t",
    stringsAsFactors = FALSE
)
```

The next step is to inspect the loaded data to ensure it looks correct.

```{r data-check}
# Check gene names
head(genes)

# Check read count dataset
dim(readcounts)
head(readcounts[, 1:5])

# Check the metadata
head(coldata_df)
```

### Data filtering and preprocessing

As a first step, before doing the diversity calculation, you might want to
filter out genes with a low overall expression or limit the analysis to
transcripts with a sufficient minimum expression level. Expression estimates of
transcript isoforms with zero or low expression might be highly variable. For
more details on the effect of transcript isoform prefiltering on differential
transcript usage, see [this paper](https://doi.org/10.1186/s13059-015-0862-3).

Filter transcripts with fewer than 5 reads in more than 5 samples and
update the `genes` vector accordingly.

```{r readfilter}
## Filter lowly-expressed transcripts and report counts
n_before <- nrow(readcounts)
tokeep <- rowSums(readcounts > 5) > 5
readcounts <- readcounts[tokeep, ]
genes <- genes[tokeep]
n_after <- nrow(readcounts)

message(sprintf(
    "Transcripts: before = %d, after = %d",
    n_before, n_after
))
```

We filter lowly-expressed transcripts to reduce noise and improve the
stability of diversity estimates.

## Compute normalized Tsallis entropy.

Compute Tsallis entropy for a single `q` and inspect the resulting assay.

```{r tsallis-calc-single}
# compute Tsallis entropy for a single q value (normalized)
q <- 0.1
ts_se <- calculate_diversity(readcounts, genes, q = q, norm = TRUE)
head(assay(ts_se)[1:5, 1:5])
```

Now we should map the sample metadata (if available) into the
`SummarizedExperiment` so plotting functions can use `sample_type`
for grouping.

```{r apply-coldata-to-se-single}
ts_se <- map_coldata_to_se(ts_se, coldata_df, paired = TRUE)
```

After mapping, inspect `colData(ts_se)` to confirm `sample_type` and
`sample_base` are present and correctly populated.

```{r inspect-coldata}
# Quick checks on mapped sample metadata
cd <- colData(ts_se)
colnames(cd) # list available metadata columns
head(cd) # preview metadata for first samples
```

## Differential analysis

This section summarizes practical guidance for hypothesis testing and
reporting when comparing diversity measures across sample groups.

The package exposes pragmatic pairwise tests for comparing per-gene
diversity summaries between two groups. Two common choices are
Wilcoxon-based tests and label-shuffle tests. Guidance:

**Wilcoxon rank-sum (unpaired) / Wilcoxon signed-rank (paired)**:

- Use when you want a distribution-free test comparing central tendency
(ranks/median) and sample sizes are moderate (typically ≥10 per group
for stable asymptotic p-values).
- Assumptions: independent observations within groups (or matched
pairs for the signed-rank test); exchangeability under the null.
- Handle ties: software returns approximate p-values when many ties
exist; consider permutation p-values when ties or discreteness are
extreme (small counts, many zeros).
- Report effect sizes (median difference, Hodges–Lehmann estimator) and
confidence intervals where possible; do not rely on p-values alone.

**Label-shuffle tests**:

- Use when sample sizes are small, distributional assumptions are
questionable, or you prefer an exact/empirical null constructed from
the observed data. Randomly shuffle group labels many times and
recompute the test statistic (difference in medians or means).
- Exchangeability requirement: permutations are valid when labels are
exchangeable under the null (e.g., independent samples). For paired
designs use paired permutations that shuffle within pairs or use sign
flips for paired differences.
- Practical settings: set `randomizations` to ≥1000 for routine use and
5000+ when estimating small p-values or when applying FDR across many
genes. When possible, compute exact permutations (all labelings) for
very small datasets.

Here we will use the **Wilcoxon test**; it is the appropriate choice for speed
when sample sizes support asymptotic approximations. Use permutation tests
when small-sample accuracy or exact control of the null distribution is
important.

**Recommendation: summary & test choice**:

For the analyses shown in this vignette we recommend using the **median**
in the **Wilcoxon** rank-sum test for comparisons. Tsallis entropy values 
are often skewed and sensitive to outliers; the median is robust and the 
Wilcoxon test does not assume normality, so  this combination is well 
suited for our analysis.

Before running differential tests we summarize per-gene diversity values across
samples and explicitly define sample groups.


```{r difference}
# create a sample grouping vector inferred from sample names
# account for per-q column names like 'Sample_q=0.01'
sample_base_names <- sub(
    "_q=.*", "",
    colnames(assay(ts_se))
)
samples <- as.character(colData(ts_se)$sample_type)

# prepare diversity table as data.frame with gene names in first column
div_df <- as.data.frame(assay(ts_se))
div_df <- cbind(genes = rowData(ts_se)$genes, div_df)

# samples are matched pairs (Normal/Tumor), so use a paired test
res <- calculate_difference(div_df, samples,
    control = "Normal",
    method = "median", test = "wilcoxon",
    paired = TRUE
)
# sort results by adjusted p-value
res <- res[order(res$adjusted_p_values), , drop = FALSE]
head(res)
```

Generate diagnostic plots to summarize per-gene effect sizes:

- The **MA plot** shows the relationship between mean expression and log-fold
change,
helping to spot genes with large effect sizes across expression levels.
- The **volcano plot** displays effect size versus significance, useful for
highlighting candidates by thresholding magnitude and adjusted p-value.

```{r ma-and-volcano, fig.width=8, fig.height=4}
# MA plot using helper
p_ma <- plot_ma(res)
print(p_ma)
# Volcano plot: mean difference vs -log10(adjusted p-value)
p_volcano <- plot_volcano(res)
print(p_volcano)
```

### Plot top 3 genes from the single-q differential analysis

Here we visualize transcript-level expression for the most significant genes
identified in the previous step. The `plot_top_transcripts()` helper expects
transcript-level counts (rows = transcripts) with rownames matching the
`tx2gene` mapping. We plot the top three genes by significance to inspect
isoform-level patterns that may explain the diversity differences.

```{r top-transcripts-singleq, fig.width=10, fig.height=6}
sig_res <- res[res$adjusted_p_values < 0.05, , drop = FALSE]
top_genes <- head(sig_res$genes, 3)
sample_base_names <- sub(
    "_q=.*",
    "",
    colnames(assay(ts_se))
)
samples_vec <- as.character(colData(ts_se)$sample_type)
# Plot using median aggregation
p_median <- plot_top_transcripts(readcounts,
    gene = top_genes,
    samples = samples_vec, tx2gene = txmap,
    top_n = NULL, metric = "median"
)
print(p_median)
```

Now, we will plot the same top genes but using variance aggregation 
instead of median. This allows us to see how transcript-level
expression variability differs between groups for these genes.

```{r top-transcripts-singleq-variance, fig.width=10, fig.height=6}
# Plot using variance aggregation
p_var <- plot_top_transcripts(readcounts,
    gene = top_genes,
    samples = samples_vec, tx2gene = txmap,
    top_n = NULL, metric = "variance"
)
print(p_var)
```

Using these concrete comparisons will help you distinguish 
consistent isoform-level regulation, outlier-driven artifacts,
reciprocal isoform switching, and subgroup heterogeneity.

## Compare between q values

Compute normalized Tsallis entropy for two `q` values (0.1 and 2) to compare
scale-dependent behavior.

```{r tsallis-calc-doble}
# compute Tsallis entropy for q = 1 (normalized)
q <- c(0.1, 2)
ts_se <- calculate_diversity(readcounts, genes,
    q = q, norm = TRUE
)
head(assay(ts_se)[1:5, 1:5])
```

This allows comparison across `q` for the same gene to determine whether
diversity differences are scale-dependent (for example, significance at
`q = 0.1` but not at `q = 2` suggests rare-isoform-driven changes).

Map optional sample metadata into the multi-q `SummarizedExperiment` so
plotting helpers have access to `sample_type` for grouping.

```{r apply-coldata-to-se-doble}
ts_se <- map_coldata_to_se(ts_se, coldata_df)
```

Create **violin and density plots** summarizing diversity across multiple `q`
values to show distributional differences between groups.

```{r plots, fig.width=10, fig.height=6}
p_violin <- plot_tsallis_violin_multq(ts_se, assay_name = "diversity")
print(p_violin)
p_density <- plot_tsallis_density_multq(ts_se, assay_name = "diversity")
print(p_density)
```

## Linear-model interaction and shape tests for q-curves

Now we will compute normalized Tsallis entropy across a sequence of `q` values.

```{r tsallis-calc-sequence}
# compute Tsallis entropy for a sequence of values (normalized)
qvec <- seq(0.01, 2, by = 0.1)
ts_se <- calculate_diversity(readcounts, genes,
    q = qvec, norm = TRUE
)
head(assay(ts_se)[1:5, 1:5])
```

Map the sample metadata into the multi-q `SummarizedExperiment` as before.

```{r apply-coldata-to-se-sequence}
ts_se <- map_coldata_to_se(ts_se, coldata_df)
```

Once we have the q-sequence computed, we 
can test for interactions between `q` and sample 
groups using a linear model. This tests 
whether the shape of the q-curve differs 
between groups, which would indicate 
scale-dependent diversity differences.


```{r lm-interaction-before-qcurve}
# Linear-model interaction test across q values: 
# detect q x group interaction
# Compute and show top hits (by adjusted p-value)
lm_res <- calculate_lm_interaction(ts_se, 
    sample_type_col = "sample_type", method = "linear",
    nthreads = 1)
print(head(lm_res, 6))
```

### Tsallis q-sequence plot

With the Tsallis q-sequence we can produces a q-curve per sample and gene. These curves
show how diversity emphasis shifts from rare to dominant isoforms as `q` increases 
and form the basis for interaction tests. The q-curve shows entropy as a function 
of `q`. Diverging curves between groups indicate scale-dependent diversity 
differences. Separation at low `q` implies differences in rare isoforms; 
separation at high `q` signals differences in dominant isoforms.

Now we will plot the q-curve profile for the top gene identified 
by the linear-model interaction test. We will start with `GFPT1`.

```{r gfpt1-gene-qprofile, fig.width=8, fig.height=5}
# Plot q-curve profile for top linear-model gene
    # Prefer GFPT1 if present; otherwise use top LM hit
plot_target <- plot_tsallis_gene_profile(ts_se, gene = "GFPT1",
    sample_type_col = "sample_type", show_samples = FALSE)
print(plot_target)
```

Now let's have a look at the `MBD2` gene, which encondes
a methyl-CpG binding domain [protein involved  in immune
cell development, function, and autoimmune
diseases9](https://www.nature.com/articles/s41420-025-02563-0).

```{r mbd2-gene-qprofile, fig.width=8, fig.height=5}
# Plot q-curve profile for top linear-model gene
    # Prefer GFPT1 if present; otherwise use top LM hit
plot_target <- plot_tsallis_gene_profile(ts_se, gene = "MBD2",
    sample_type_col = "sample_type", show_samples = FALSE)
print(plot_target)
```

We could also generate the q-sequence profile for `EEF2K`.
This gene codifies an [protein kinase associated with 
cancer survival and 
prognosis](https://www.nature.com/articles/s41598-024-78652-4).

```{r eef2k-gene-qprofile, fig.width=8, fig.height=5}
# Plot q-curve profile for top linear-model gene
    # Prefer GFPT1 if present; otherwise use top LM hit
plot_target <- plot_tsallis_gene_profile(ts_se, gene = "EEF2K",
    sample_type_col = "sample_type", show_samples = FALSE)
print(plot_target)
```

We can plot also the **overall Tsallis q-curve for all
genes**. This kind of plot provides a global view of how 
diversity changes across the `q` spectrum for the
entire dataset, and can reveal general trends in 
isoform diversity.

```{r tsallis-q-curve, fig.width=12, fig.height=6, echo=FALSE}
# Plot top tsallis q curve
p_qcurve <- plot_tsallis_q_curve(ts_se)#print(p_top_lm)
print(p_qcurve)
```



## Practical notes and recommendations

Quick checklist (what to do and why):

- **Preprocess**: filter transcripts never observed or add a small, documented
pseudocount (e.g., +1) — this stabilizes proportions and avoids
undefined powers when computing `p_i^q`.
- **Choose `q` grid**: pick a compact set spanning rare → dominant regimes
(suggested: 0.1, 0.5, 1, 1.5, 2). Plot q-curves to inspect where
groups diverge rather than relying on a single `q`.
- **Reporting scale**: present Hill numbers `D_q` (intuitive "effective
isoforms") and/or normalized entropy \(\tilde S_q\); report both
effect size (median/mean difference) and variability (CI or bootstrap SE).
- **Hypothesis testing**: use Wilcoxon for speed (asymptotic) and
label-shuffle (permutation) for small samples or exact inference.
For permutations use `randomizations` ≥1000 (≥5000 when estimating
very small p-values); use paired permutations for matched designs.
- **Multiple testing**: apply FDR correction (Benjamini–Hochberg) and show
raw/adjusted p-values alongside effect sizes so readers can judge
practical relevance.
- **Interaction testing**: explore slopes/AUC first; use linear interaction for
simple slope differences, GAMs for nonlinear shapes, and FPCA for fast
low-dimensional summaries — always report key parameters (`k`,
`randomizations`).
- **Design & technical tips**: prefer paired/matched designs when available,
ensure adequate biological replication, use accurate quantifiers
(Salmon/kallisto or UMI-based methods), and correct for confounders or
include them in models.
- **Design examples**: time-series or longitudinal sampling to capture dynamics;
perturbation gradients (dose–response) to reveal transitions; single-cell
or spatial (UMI-based) to study heterogeneity; paired/matched designs to
control subject-level variability.
- **Technical checklist**: use accurate transcript quantifiers, aim for
sufficient sequencing depth for isoform inference, filter or pseudocount
low-abundance transcripts, and apply batch/confounder correction prior
to downstream testing. Test across a compact `q` grid and report the grid.


## Session info

```{r session-info}
sessionInfo()
```
