---
title: "TSENAT: Tsallis Entropy Analysis Toolbox"
author: "Cristóbal Gallardo <gallardoalba@pm.me>"
date: "`r Sys.Date()`"
output:
    rmarkdown::html_document:
        toc: true
        fig_width: 7
        fig_height: 4.5
vignette: |
    %\VignetteIndexEntry{TSENAT}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r setup-global, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    fig.width = 7,
    fig.height = 4.5
)
```

## Overview

This vignette demonstrates how to compute and apply Tsallis entropy to
transcript-level expression data using `TSENAT`. It focuses on three
practical goals: (1) compute per-sample, per-gene diversity measures across a
range of sensitivity parameters `q`; (2) compare those measures between sample
groups; and (3) visualize and inspect transcript-level patterns that explain
differences.

### Motivation

Common RNA-seq tools, such as DESEQ2 o SALMON, focus on changes in total gene abundance. 
While powerful, that view can obscure an important biological phenomenon: genes often 
change *which* isoforms they express without large changes in overall expression. Tsallis 
entropy gives you a single, coherent framework to describe those changes. By tuning the 
parameter `q` you slide a lens across abundance scales—zooming in on rare variants or 
zooming out to the dominant isoforms—so you can capture scale-dependent isoform 
switching that ordinary summaries overlook.

### High-level workflow

1. Preprocess counts and filter low-abundance transcripts.
2. Compute relative transcript proportions within each gene and evaluate
Tsallis entropy across one or more `q` values.
3. Summarize per-gene values across samples (mean/median) and test for
differences between groups (Wilcoxon or permutations).
4. Visualize q-curves and inspect transcript-level counts for top genes.


## What is Tsallis entropy?

Tsallis entropy is a one-parameter family of diversity measures that
generalizes Shannon entropy via a sensitivity parameter `q`. For a
discrete probability vector $p=(p_1,\dots,p_n)$ it is defined as

\[
S_q(p) = \frac{1-\sum_{i=1}^n p_i^q}{q-1}.
\]

Changing `q` shifts emphasis between rare and abundant isoforms: small 
values of `q` make the measure sensitive to low-abundance variants,
while larger `q` focus on the dominant species. In practice, computing 
`S_q` across a short grid of `q` values (a "q-curve") and combining
this with resampling or paired designs yields a concise, interpretable
summary of isoform heterogeneity.

Key advantages:

- **Tunable sensitivity**: changing `q` shifts emphasis between rare and
dominant isoforms. Use small `q` (\(<1\)) to probe rare-isoform
heterogeneity and larger `q` (\(>1\)) to focus on dominant-isoform
behaviour; plotting `S_q` across a compact `q` grid (a "q-curve")
reveals scale-dependent differences between conditions.
- **Interpretability**: Tsallis maps to several familiar indices in limits
(Shannon at `q=1`, richness-like at `q=0`, Gini–Simpson at `q=2`), so
it unifies multiple perspectives on isoform diversity within one
framework.
- **Robust summary and diagnostics**: combined with Hill numbers and
q-curves, `S_q` supports concise reporting (effective isoform counts,
slope/AUC summaries) and targeted follow-up (transcript-level plots).

**Essential limiting cases**:

- Limit $q\to 1$: Shannon entropy, \(\lim_{q\to1} S_q(p) = -\sum_i p_i\log
p_i\).
- $q=0$: richness-like (number of expressed isoforms minus one).
- $q=2$: Gini–Simpson / collision index, \(S_2 = 1-\sum_i p_i^2\).
- Uniform maximum: for $m$ expressed isoforms,
\(S_{q,\max}(m)=\frac{1-m^{1-q}}{q-1}\) and normalized
\(\tilde S_q = S_q / S_{q,\max}(m)\).

**Use cases and interpretation**

Read q-curves as a diagnostic: if groups separate at **low q** the biological
signal is in the rare isoforms; separation at **high q** points to changes in the
dominant isoform. When separation occurs across the curve, the whole isoform
composition has shifted. For reporting, consider transforming entropies to
Hill numbers $D_q$ ("effective isoform counts") which are often more intuitive
for readers.

## Example dataset

An example dataset is included for demonstration.

```{r setup}
# Load packages
suppressPackageStartupMessages({
    library(TSENAT)
    library(ggplot2)
    library(SummarizedExperiment)
    library(mgcv)
})
```

### Load data and metadata

Now we will load the example dataset and associated metadata:

```{r data}
# Load required files
coldata_tsv <- system.file("extdata", "coldata.tsv", package = "TSENAT")
tx2gene_tsv <- system.file("extdata", "tx2gene.tsv", package = "TSENAT")
data("tcga_brca_luma_dataset", package = "TSENAT", envir = globalenv())

# Extract gene names and read count data
genes <- tcga_brca_luma_dataset[, 1]
readcounts <- tcga_brca_luma_dataset[, -1]

# Read sample metadata
coldata_df <- read.table(coldata_tsv,
    header = TRUE,
    sep = "\t",
    stringsAsFactors = FALSE
)
```

The next step is to inspect the loaded data to 
ensure it looks correct.

```{r data-check}
# Check gene names
head(genes)

# Check read count dataset
dim(readcounts)
head(readcounts[1:4, 1:3])

# Check the metadata
head(coldata_df)
```

### Data preprocessing and filtering

If the transcript IDs in `readcounts` are not already set
as rownames, we need to map them. This step could be skipped
if the dataset already has transcript IDs as rownames, 
but in this case we need to assign them.

```{r map-transcripts-ids}
# Assign transcript IDs as rownames of `readcounts`
readcounts <- map_tx_to_readcounts(readcounts, tx2gene_tsv)
# ensure `genes` is name-indexable by transcript id so we can subset by
# filtered rownames; if `genes` has no names, assign the original
# readcount rownames (which correspond to transcripts)
if (is.null(names(genes))) {
    names(genes) <- rownames(readcounts)
}
```

```{r build-se}
## Build a `SummarizedExperiment` from readcounts + tx2gene mapping
# Uses helper `build_se_from_readcounts()` added to the package
se <- build_se(tx2gene_tsv, readcounts, genes)
```



Before doing the diversity calculation, you might want to
filter out genes with a low overall expression or limit 
the analysis to transcripts with a sufficient minimum 
expression level. Expression estimates of transcript isoforms 
with zero or low expression might be highly variable.
For more details on the effect of transcript isoform
prefiltering on differential transcript usage, see 
[this paper](https://doi.org/10.1186/s13059-015-0862-3).

Filter transcripts with fewer than 5 reads in more than 5 samples and
update the `genes` vector accordingly.

```{r readfilter}
## Filter lowly-expressed transcripts and report counts
# Keep transcripts with >5 reads in more than 5 samples using `filter_se()`
se <- filter_se(se, min_count = 5, min_samples = 5)
```

We filter lowly-expressed transcripts to reduce noise and improve the
stability of diversity estimates.



## Compute normalized Tsallis entropy.

Compute Tsallis entropy for a single `q` and inspect the resulting assay.

Note: si su estudio es unimodal (es decir, sólo dispone de una condición), puede
igualmente calcular y explorar la entropía de Tsallis como análisis descriptivo.


```{r tsallis-calc-single}
# compute Tsallis entropy for a single q value (normalized)
q <- 0.1
ts_se <- calculate_diversity(se, q = q, norm = TRUE)
head(assay(ts_se)[1:4, 1:3])
```

An additional important technical factor is the data 
normalization, which makes values comparable across 
genes with different numbers of isoforms.

Now we should map the sample metadata (if available) into the
`SummarizedExperiment` so plotting functions can use `sample_type`
for grouping.

```{r apply-coldata-to-se-single}
ts_se <- map_coldata_to_se(ts_se, coldata_df, paired = TRUE)
```

## Differential analysis

This section summarizes practical guidance for hypothesis testing and
reporting when comparing diversity measures across sample groups.

The package exposes pragmatic pairwise tests for comparing per-gene
diversity summaries between two groups. Two common choices are
Wilcoxon-based tests and label-shuffle tests. Guidance:

**Wilcoxon rank-sum (unpaired) / Wilcoxon signed-rank (paired)**:

- Use when you want a distribution-free test comparing central 
tendency (ranks/median) and sample sizes are moderate (typically 
≥10 per group for stable asymptotic p-values).
- Assumptions: independent observations within groups (or matched
pairs for the signed-rank test); exchangeability under the null.
- Handle ties: software returns approximate p-values when many ties
exist; consider permutation p-values when ties or discreteness are
extreme (small counts, many zeros).
- Report effect sizes (median difference, Hodges–Lehmann estimator) 
and confidence intervals where possible; do not rely on 
p-values alone.

**Label-shuffle tests**:

- Use when sample sizes are small, distributional assumptions are
questionable, or you prefer an exact/empirical null constructed from
the observed data. Randomly shuffle group labels many times and
recompute the test statistic (difference in medians or means).
- Exchangeability requirement: permutations are valid when labels are
exchangeable under the null (e.g., independent samples). For paired
designs use paired permutations that shuffle within pairs or use sign
flips for paired differences.
- Practical settings: set `randomizations` to ≥1000 for routine use and
5000+ when estimating small p-values or when applying FDR across many
genes. When possible, compute exact permutations (all labelings) for
very small datasets.
- For paired designs an exact sign-flip test enumerates all possible
combinations of within-pair label flips. Use `paired = TRUE` and
`paired_method = "signflip"` and set `randomizations = 0` to trigger 
exact enumeration for small numbers of pairs. 

Here we will use the **Wilcoxon test**; it is the appropriate choice for speed
when sample sizes support asymptotic approximations. Use permutation tests
when small-sample accuracy or exact control of the null distribution is
important.

**Recommendation: summary & test choice**:

For the analyses shown in this vignette we recommend using the **median**
in the **Wilcoxon** rank-sum test for comparisons. Tsallis entropy values 
are often skewed and sensitive to outliers; the median is robust and the 
Wilcoxon test does not assume normality, so  this combination is well 
suited for our analysis.

Before running differential tests we need to summarize per-gene diversity
values across samples and explicitly define sample groups.


```{r difference}
# create a sample grouping vector inferred from sample names
# account for per-q column names like 'Sample_q=0.01'
sample_base_names <- sub(
    "_q=.*", "",
    colnames(assay(ts_se))
)
samples <- as.character(colData(ts_se)$sample_type)

# prepare diversity table as data.frame with gene names in first column
div_df <- as.data.frame(assay(ts_se))
div_df <- cbind(genes = rowData(ts_se)$genes, div_df)

# samples are matched pairs (Normal/Tumor), so use a paired test
res <- calculate_difference(div_df, samples,
    control = "Normal",
    method = "median", test = "wilcoxon",
    paired = TRUE
)
# sort results by adjusted p-value
res <- res[order(res$adjusted_p_values), , drop = FALSE]
head(res)
```

After the statistical test we can generate two kind of
diagnostic plots to summarize per-gene effect sizes: MA plots
and volcano plots.


First we will plot a **Tsallis-based MA**, 
which uses the Tsallis entropy values directly to compute fold 
changes and mean expression. This plot provides a direct view of 
how diversity differences relate to overall expression levels.

```{r ma-tsallis, fig.width=7, fig.height=4.5}
# MA plot (Tsallis-based)
p_ma <- plot_ma(res, type = "tsallis")
print(p_ma)
```

Second, we will plot an **expression/readcount-based MA**, which
uses the original read counts to compute fold changes and mean
expression. This plot helps to contextualize diversity
differences in terms of overall gene expression levels.

```{r ma-readcounts, fig.width=7, fig.height=4.5}
# MA plot (expression/readcount-based)
p_ma_read <- plot_ma(
    res,
    type = "expression",
    se = ts_se,
    control = "Normal"
)
print(p_ma_read)
```

The **volcano plot** displays effect size versus significance,
useful for highlighting genes with large, significant differences. 

```{r ,volcanoplot, fig.width=7, fig.height=4.5}
# Volcano plot: mean difference vs -log10(adjusted p-value)
p_volcano <- plot_volcano(res)
print(p_volcano)
```

### Plot top 3 genes from the single-q differential analysis

Here we will visualize the transcript-level expression for the 
most significant genes identified in the previous step. The 
`plot_top_transcripts()` function expects transcript-level 
counts (rows = transcripts) with rownames matching the `tx2gene` 
mapping. Now will plot the top three genes by significance 
to inspect isoform-level patterns that may explain the 
diversity differences.

```{r top-transcripts-singleq, fig.width=7, fig.height=4.5}
# Plot using median aggregation; let the function pick top genes from `res`
p_median <- plot_top_transcripts(ts_se,
    res = res, top_n = 3, metric = "median"
)
print(p_median)
```

Now, we will plot the same top genes but using variance aggregation 
instead of median. This allows us to see how transcript-level
expression variability differs between groups for these genes.

```{r top-transcripts-singleq-variance, fig.width=7, fig.height=4.5}
# Plot using variance aggregation
p_var <- plot_top_transcripts(ts_se,
    res = res, top_n = 3, metric = "variance"
)
print(p_var)
```

Using these concrete comparisons will help you distinguish 
consistent isoform-level regulation, outlier-driven artifacts,
reciprocal isoform switching, and subgroup heterogeneity.

## Compare between q values

Now we are going to try a different approach. In instead of
evaluate the sificant estatistical differences by using single
Thassi `q` values, we will compute  the normalized Tsallis 
entropy for two `q` values (0.1 and 2) to studiy  potential
scale-dependent patterns.

```{r tsallis-calc-doble}
# compute Tsallis entropy for q = 1 (normalized)
q <- c(0.1, 2)
ts_se <- calculate_diversity(se,
    q = q, norm = TRUE
)
head(assay(ts_se)[1:4,1:3])
```

This allows comparison across `q` for the same gene to determine whether
diversity differences are scale-dependent (for example, significance at
`q = 0.1` but not at `q = 2` suggests rare-isoform-driven changes).

Once again, we should map the sample metadata into the multi-q 
`SummarizedExperiment` so, plotting helpers can have access to 
`sample_type` for grouping.

```{r apply-coldata-to-se-doble}
ts_se <- map_coldata_to_se(ts_se, coldata_df)
```

In order to show the distributional differences
between groups, we are going to create **violin and density plots**.

```{r plots-violin, fig.width=7, fig.height=4.5}
p_violin <- plot_tsallis_violin_multq(ts_se, assay_name = "diversity")
print(p_violin)
```

```{r plots-density, fig.width=7, fig.height=4.5}
p_density <- plot_tsallis_density_multq(ts_se, assay_name = "diversity")
print(p_density)
```

## Linear-model interaction and shape tests for q-curves

Now we will compute normalized Tsallis entropy across a 
sequence of `q` values.

Computing Tsallis entropy across a sequence of q values 
is important because q acts as a sensitivity lens that 
shifts emphasis between rare and dominant isoforms, 
so the resulting **q-curve** reveals the scale at which 
biological differences occur.

The Tsallis q-sequence can help us with QC and the detection
of outlier datasets; aside from that, throught the implementation
of different inference  approaches (whether to use multivariate 
approaches such as `q:group` interaction models, GAMs, or FPCA),
is it possible to obtain a level o diagnostic power and robustness
das is not possible to optain on a single arbitrary `q` values.

```{r tsallis-calc-sequence}
# compute Tsallis entropy for a sequence of values (normalized)
qvec <- seq(0.1, 2, by = 0.05)
ts_se <- calculate_diversity(se,
    q = qvec, norm = TRUE
)
head(assay(ts_se)[1:4,1:3])
```

Map once again the sample metadata into the multi-q 
`SummarizedExperiment` as before.

```{r apply-coldata-to-se-sequence}
# For paired designs ensure sample_base is created so LMMs can use it
ts_se <- map_coldata_to_se(ts_se, coldata_df, paired = TRUE)
```

Once we have the `q-sequence` computed, we can test for 
interactions between `q` and sample groups using 
**mixed models** that include a random intercept per 
subject to account for paired samples. One practical
approach is the **Satterthwaite method**.

This method is preferable for small or moderately sized 
paired RNA‑seq studies when per-term inference is required 
(for example, the `q:group` interaction).

```{r lm-interaction-before-qcurve}
## Linear-model interaction test across q values: detect q x group interaction
## Guard the LMM-based analysis so the vignette renders even when 'lme4' is
## not available in the environment (CI may skip Suggests).
if (requireNamespace("lme4", quietly = TRUE)) {
    # Compute and show top hits (by adjusted p-value)
    lm_res <- calculate_lm_interaction(ts_se,
            sample_type_col = "sample_type", method = "lmm",
            pvalue = "satterthwaite",
            subject_col = "sample_base")
    print(head(lm_res, 6))
} else {
    message("Skipping linear-model LMM interaction test: package 'lme4' not installed in this environment.")
}
```

### Tsallis q-sequence plot

With the **Tsallis q-sequence** we can produce a q-curve per sample and gene.
These curves show how diversity emphasis shifts from rare to dominant
isoforms as `q` increases and form the basis for interaction tests. The
q-curve shows entropy as a function of `q`. Diverging curves between
groups indicate **scale-dependent diversity differences**: separation at low
`q` implies differences in rare isoforms, while separation at high `q`
signals differences in dominant isoforms.

Now we will plot the q-curve profile for the top gene identified 
by the linear-model interaction test. We will start with `HAPLN3`.

```{r hapln3-gene-qprofile, fig.width=7, fig.height=4.5}
# Plot q-curve profile for top linear-model gene
plot_target <- plot_tsallis_gene_profile(ts_se, gene = "HAPLN3")
print(plot_target)
```

Now let's look at `COL1A2`, which encodes a protein involved in immune
cell biology and has been reported as differentially regulated in some
cancer studies.

```{r colia2-gene-qprofile, fig.width=7, fig.height=4.5}
# Plot q-curve profile for top linear-model gene
plot_target <- plot_tsallis_gene_profile(ts_se, gene = "COL1A2")
print(plot_target)
```

From the plot we might infer that, in this dataset, rare transcripts
appear more prevalent in cancer samples.

Finally, we can visualize the gene `PI16`, which is emerging
as an important regulator in the vascular system.

```{r pi16-gene-qprofile, fig.width=7, fig.height=4.5}
# Plot q-curve profile for top linear-model gene
plot_target <- plot_tsallis_gene_profile(ts_se, gene = "PI16")
print(plot_target)
```

We can also plot the **overall Tsallis q-curve for all genes**. This
plot provides a global view of how diversity changes across the `q`
spectrum for the entire dataset and can reveal general trends in
isoform diversity.

```{r tsallis-q-curve, fig.width=7, fig.height=4.5}
# Plot top tsallis q curve
p_qcurve <- plot_tsallis_q_curve(ts_se)
print(p_qcurve)
```

## Practical notes and recommendations

Accurate isoform quantification is the foundation of reliable
entropy analysis. Small counts introduce noise; missing data 
distorts proportions. Some important elements to keep in mind:

- **Transcript abundance filtering**: Remove very low-count transcripts to 
reduce technical noise (typical rule: drop transcripts with <5 reads in >5 
samples, but adjust to sequencing depth).
- **Pseudocounts**: If zeros create numerical issues, you coud add
a small pseudocount (e.g. 1e-10). You can find more information about
pseudocoints in this [paper](https://doi.org/10.1093/bioinformatics/bty471).
- **Quantification & normalization**: use bias-aware quantifiers,
such Salmon or kallisto.


```{r session-info}
sessionInfo()
```
